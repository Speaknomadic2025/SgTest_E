// Phase 2 Implementation: Active Speed Test Functionality
// Built on successful Phase 1 infrastructure
// Includes full speed test logic with safety protections

// This file is automatically generated from MainActivity_restored_working_110725.kt
// Phase 1 Implementation: Speed Test Infrastructure (Dormant)
// All speed test functionality is dormant - no network activity
// This ensures zero risk to existing functionality


package com.example.signaltestenhanced

import android.Manifest
import android.annotation.SuppressLint
import android.content.Context
import android.content.pm.PackageManager
import android.location.Location
import android.location.LocationListener
import android.location.LocationManager
import android.net.wifi.WifiManager
import android.os.Build
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.provider.Settings
import android.telephony.CellInfoLte
import android.telephony.CellInfoNr
import android.telephony.CellSignalStrengthLte
import android.telephony.CellSignalStrengthNr
import android.telephony.TelephonyDisplayInfo
import android.telephony.TelephonyManager
import android.telephony.PhoneStateListener
import android.util.Log
import android.widget.Button
import android.widget.LinearLayout
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import org.json.JSONObject
import java.io.OutputStreamWriter
import java.net.HttpURLConnection
import java.net.URL
import javax.net.ssl.HttpsURLConnection
import kotlin.concurrent.thread
import java.util.concurrent.Executors
import java.util.concurrent.atomic.AtomicReference

class MainActivity : AppCompatActivity(), LocationListener {

    companion object {
        private const val TAG = "MainActivity"
        private const val PERMISSION_REQUEST_CODE = 1001
    }

    // UI Components
    private lateinit var deviceInfoText: TextView
    private lateinit var gpsInfoText: TextView
    private lateinit var signal4gText: TextView
    private lateinit var signal5gText: TextView
    private lateinit var generalSignalText: TextView
    private lateinit var statusText: TextView
    private lateinit var startButton: Button
    private lateinit var stopButton: Button

    // 5G/4G Status Icons
    private lateinit var fiveGIcon: TextView
    private lateinit var fourGIcon: TextView
    private lateinit var networkStatusText: TextView

    // System Services
    private lateinit var telephonyManager: TelephonyManager
    private lateinit var locationManager: LocationManager
    private lateinit var wifiManager: WifiManager

    // Data
    private lateinit var deviceId: String
    private var lastLocation: Location? = null
    private var isMonitoring = false
    private var isServerAvailable = false
    private var serverBaseUrl = ""
    private var connectionType = "Unknown"
    private var monitoringHandler: Handler? = null
    private var monitoringRunnable: Runnable? = null

    // Signal data
    private var currentSignalStrength: Int = -999
    private var currentNetworkType: String = "Unknown"
    private var currentCarrier: String = "Unknown"

    // 5G Detection
    private var is5GActive = false
    private var phoneStateListener: PhoneStateListener? = null

    // Speed Test Infrastructure (Phase 1 - Dormant)
    @Volatile private var isSpeedTestRunning = false
    @Volatile private var speedTestQueueId: String? = null
    private val speedTestResults = AtomicReference<SpeedTestResult?>(null)
    private val speedTestExecutor = Executors.newSingleThreadExecutor { r ->
        Thread(r, "SpeedTest-Thread").apply {
            isDaemon = true
            priority = Thread.MIN_PRIORITY
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        Log.d(TAG, "=== INTERNET READY VERSION 20250110_1200 ===")
        Log.d(TAG, "Android API Level: ${Build.VERSION.SDK_INT}")

        createUI()
        initializeServices()
        checkPermissions()
    }

    private fun createUI() {
        val layout = LinearLayout(this).apply {
            orientation = LinearLayout.VERTICAL
            setPadding(32, 32, 32, 32)
        }

        // App Title
        val titleText = TextView(this).apply {
            text = "SignalTestEnhanced - Internet Ready"
            textSize = 24f
            setTypeface(null, android.graphics.Typeface.BOLD)
            setPadding(0, 0, 0, 40)
        }
        layout.addView(titleText)

        // Device Info
        deviceInfoText = TextView(this).apply {
            text = "Device Info: Loading..."
            textSize = 14f
            setPadding(0, 0, 0, 16)
        }
        layout.addView(deviceInfoText)

        // GPS Info
        gpsInfoText = TextView(this).apply {
            text = "GPS: Not available"
            textSize = 14f
            setPadding(0, 0, 0, 16)
        }
        layout.addView(gpsInfoText)

        // Network Status Icons Section
        val networkSectionTitle = TextView(this).apply {
            text = "ðŸ“¶ Network Status"
            textSize = 18f
            setTypeface(null, android.graphics.Typeface.BOLD)
            setPadding(0, 20, 0, 16)
        }
        layout.addView(networkSectionTitle)

        // Icons Container
        val iconsContainer = LinearLayout(this).apply {
            orientation = LinearLayout.HORIZONTAL
            setPadding(0, 0, 0, 16)
        }

        // 5G Icon Container
        val fiveGContainer = LinearLayout(this).apply {
            orientation = LinearLayout.VERTICAL
            layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
            setPadding(16, 0, 16, 0)
        }

        fiveGIcon = TextView(this).apply {
            text = "5G"
            textSize = 20f
            setTypeface(null, android.graphics.Typeface.BOLD)
            textAlignment = TextView.TEXT_ALIGNMENT_CENTER
            setTextColor(ContextCompat.getColor(this@MainActivity, android.R.color.darker_gray))
            background = ContextCompat.getDrawable(this@MainActivity, android.R.drawable.btn_default)
            setPadding(16, 16, 16, 16)
        }
        fiveGContainer.addView(fiveGIcon)

        val fiveGLabel = TextView(this).apply {
            text = "5G Network"
            textSize = 12f
            textAlignment = TextView.TEXT_ALIGNMENT_CENTER
            setPadding(0, 8, 0, 0)
        }
        fiveGContainer.addView(fiveGLabel)

        // 4G Icon Container
        val fourGContainer = LinearLayout(this).apply {
            orientation = LinearLayout.VERTICAL
            layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
            setPadding(16, 0, 16, 0)
        }

        fourGIcon = TextView(this).apply {
            text = "4G"
            textSize = 20f
            setTypeface(null, android.graphics.Typeface.BOLD)
            textAlignment = TextView.TEXT_ALIGNMENT_CENTER
            setTextColor(ContextCompat.getColor(this@MainActivity, android.R.color.holo_green_dark))
            background = ContextCompat.getDrawable(this@MainActivity, android.R.drawable.btn_default)
            setPadding(16, 16, 16, 16)
        }
        fourGContainer.addView(fourGIcon)

        val fourGLabel = TextView(this).apply {
            text = "4G/LTE"
            textSize = 12f
            textAlignment = TextView.TEXT_ALIGNMENT_CENTER
            setPadding(0, 8, 0, 0)
        }
        fourGContainer.addView(fourGLabel)

        iconsContainer.addView(fiveGContainer)
        iconsContainer.addView(fourGContainer)
        layout.addView(iconsContainer)

        // Network Status Text
        networkStatusText = TextView(this).apply {
            text = "Network: Detecting..."
            textSize = 14f
            setPadding(0, 0, 0, 16)
        }
        layout.addView(networkStatusText)

        // Signal Info Section
        val signalSectionTitle = TextView(this).apply {
            text = "ðŸ“Š Signal Strength"
            textSize = 18f
            setTypeface(null, android.graphics.Typeface.BOLD)
            setPadding(0, 20, 0, 16)
        }
        layout.addView(signalSectionTitle)

        signal4gText = TextView(this).apply {
            text = "4G Signal: --"
            textSize = 16f
            setPadding(0, 0, 0, 8)
        }
        layout.addView(signal4gText)

        signal5gText = TextView(this).apply {
            text = "5G Signal: Not detected"
            textSize = 16f
            setPadding(0, 0, 0, 8)
        }
        layout.addView(signal5gText)

        generalSignalText = TextView(this).apply {
            text = "General Signal: --"
            textSize = 14f
            setPadding(0, 0, 0, 16)
        }
        layout.addView(generalSignalText)

        // Control Buttons
        val buttonContainer = LinearLayout(this).apply {
            orientation = LinearLayout.HORIZONTAL
            setPadding(0, 20, 0, 16)
        }

        startButton = Button(this).apply {
            text = "START MONITORING"
            layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
            setOnClickListener { startMonitoring() }
        }
        buttonContainer.addView(startButton)

        stopButton = Button(this).apply {
            text = "STOP MONITORING"
            layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
            setOnClickListener { stopMonitoring() }
            isEnabled = false
        }
        buttonContainer.addView(stopButton)

        layout.addView(buttonContainer)

        // Status
        statusText = TextView(this).apply {
            text = "Ready to start monitoring"
            textSize = 14f
            textAlignment = TextView.TEXT_ALIGNMENT_CENTER
        }
        layout.addView(statusText)

        setContentView(layout)
    }

    private fun initializeServices() {
        telephonyManager = getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager
        locationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager
        wifiManager = applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager

        deviceId = Settings.Secure.getString(contentResolver, Settings.Secure.ANDROID_ID)

        updateDeviceInfo()
    }

    @SuppressLint("MissingPermission")
    private fun setupTelephonyListener() {
        if (!hasPhonePermission()) {
            Log.w(TAG, "Phone permission not granted, cannot setup telephony listener")
            return
        }

        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                phoneStateListener = object : PhoneStateListener() {
                    @Suppress("DEPRECATION")
                    override fun onDisplayInfoChanged(telephonyDisplayInfo: TelephonyDisplayInfo) {
                        super.onDisplayInfoChanged(telephonyDisplayInfo)

                        Log.d(TAG, "=== TELEPHONY DISPLAY INFO CHANGED ===")

                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                            try {
                                val networkType = if (Build.VERSION.SDK_INT >= 30) {
                                    telephonyDisplayInfo.networkType
                                } else {
                                    -1
                                }

                                val overrideNetworkType = if (Build.VERSION.SDK_INT >= 30) {
                                    telephonyDisplayInfo.overrideNetworkType
                                } else {
                                    -1
                                }

                                Log.d(TAG, "Network Type: $networkType")
                                Log.d(TAG, "Override Network Type: $overrideNetworkType")

                                handleDisplayInfoChanged(networkType, overrideNetworkType)

                            } catch (e: Exception) {
                                Log.e(TAG, "Error reading TelephonyDisplayInfo: ${e.message}")
                            }
                        }
                    }
                }

                telephonyManager.listen(phoneStateListener, PhoneStateListener.LISTEN_DISPLAY_INFO_CHANGED)
                Log.d(TAG, "PhoneStateListener with DisplayInfo registered")

            } else {
                Log.w(TAG, "TelephonyDisplayInfo not available on Android < 11, using fallback detection")
            }

        } catch (e: SecurityException) {
            Log.e(TAG, "SecurityException setting up telephony listener: ${e.message}")
        } catch (e: Exception) {
            Log.e(TAG, "Error setting up telephony listener: ${e.message}")
        }
    }

    private fun handleDisplayInfoChanged(networkType: Int, overrideNetworkType: Int) {
        val was5GActive = is5GActive

        is5GActive = if (Build.VERSION.SDK_INT >= 30) {
            when (overrideNetworkType) {
                1, 3, 4 -> {
                    Log.d(TAG, "5G NSA/Advanced detected via TelephonyDisplayInfo!")
                    true
                }
                else -> {
                    Log.d(TAG, "No 5G override detected, checking base network type")
                    networkType == TelephonyManager.NETWORK_TYPE_NR
                }
            }
        } else {
            networkType == TelephonyManager.NETWORK_TYPE_NR
        }

        Log.d(TAG, "5G Status: was=$was5GActive, now=$is5GActive")

        if (was5GActive != is5GActive) {
            runOnUiThread {
                updateNetworkIcons()
                updateSignalInfo()
            }
        }
    }

    private fun hasPhonePermission(): Boolean {
        return ContextCompat.checkSelfPermission(this, Manifest.permission.READ_PHONE_STATE) == PackageManager.PERMISSION_GRANTED
    }

    private fun updateNetworkIcons() {
        runOnUiThread {
            if (is5GActive) {
                fiveGIcon.setTextColor(ContextCompat.getColor(this, android.R.color.holo_green_dark))
                fourGIcon.setTextColor(ContextCompat.getColor(this, android.R.color.darker_gray))
                networkStatusText.text = "Network: 5G NSA Active"
                Log.d(TAG, "UI Updated: 5G ACTIVE (Green 5G, Grey 4G)")
            } else {
                fiveGIcon.setTextColor(ContextCompat.getColor(this, android.R.color.darker_gray))
                fourGIcon.setTextColor(ContextCompat.getColor(this, android.R.color.holo_green_dark))
                networkStatusText.text = "Network: 4G/LTE Active"
                Log.d(TAG, "UI Updated: 4G ONLY (Grey 5G, Green 4G)")
            }
        }
    }

    private fun updateDeviceInfo() {
        val model = Build.MODEL
        val androidVersion = Build.VERSION.RELEASE

        runOnUiThread {
            deviceInfoText.text = "Device ID: ${deviceId.take(12)}...\nModel: $model\nAndroid: $androidVersion (API ${Build.VERSION.SDK_INT})"
        }
    }

    @SuppressLint("MissingPermission")
    private fun updateSignalInfo() {
        try {
            Log.d(TAG, "=== SIGNAL UPDATE START ===")

            if (!hasPhonePermission()) {
                Log.w(TAG, "Phone permission not granted, cannot read signal info")
                runOnUiThread {
                    signal4gText.text = "4G Signal: Permission required"
                    signal5gText.text = "5G Signal: Permission required"
                    generalSignalText.text = "Phone permission required"
                }
                return
            }

            val cellInfoList = telephonyManager.allCellInfo
            var has4G = false
            var has5GCells = false

            // FIXED: Track the STRONGEST signals instead of last processed
            var bestSignalStrength4G = -999
            var bestSignalStrength5G = -999
            var cellCount4G = 0
            var cellCount5G = 0

            Log.d(TAG, "CellInfoList: ${if (cellInfoList != null) "Available (${cellInfoList.size} cells)" else "NULL"}")

            cellInfoList?.forEach { cellInfo ->
                Log.d(TAG, "Processing cell: ${cellInfo.javaClass.simpleName}")

                when (cellInfo) {
                    is CellInfoLte -> {
                        has4G = true
                        cellCount4G++
                        val lteSignal = cellInfo.cellSignalStrength as CellSignalStrengthLte
                        val rsrp = lteSignal.rsrp
                        if (rsrp != Int.MAX_VALUE && rsrp < 0) {
                            Log.d(TAG, "Valid 4G signal: ${rsrp}dBm")

                            // FIXED: Keep the STRONGEST signal (closest to 0)
                            if (bestSignalStrength4G == -999 || rsrp > bestSignalStrength4G) {
                                bestSignalStrength4G = rsrp
                                Log.d(TAG, "NEW BEST 4G signal: ${rsrp}dBm")
                            }
                        }
                    }
                    is CellInfoNr -> {
                        has5GCells = true
                        cellCount5G++
                        val nrSignal = cellInfo.cellSignalStrength as CellSignalStrengthNr
                        val ssRsrp = nrSignal.ssRsrp
                        if (ssRsrp != Int.MAX_VALUE && ssRsrp < 0) {
                            Log.d(TAG, "Valid 5G signal: ${ssRsrp}dBm")

                            // FIXED: Keep the STRONGEST signal (closest to 0)
                            if (bestSignalStrength5G == -999 || ssRsrp > bestSignalStrength5G) {
                                bestSignalStrength5G = ssRsrp
                                Log.d(TAG, "NEW BEST 5G signal: ${ssRsrp}dBm")
                            }
                        }
                    }
                }
            }

            Log.d(TAG, "Signal Selection Summary:")
            Log.d(TAG, "  - 4G Cells: $cellCount4G, Best Signal: ${if (bestSignalStrength4G != -999) "${bestSignalStrength4G}dBm" else "None"}")
            Log.d(TAG, "  - 5G Cells: $cellCount5G, Best Signal: ${if (bestSignalStrength5G != -999) "${bestSignalStrength5G}dBm" else "None"}")

            // Enhanced 5G detection combining multiple methods
            val dataNetworkType = telephonyManager.dataNetworkType
            val voiceNetworkType = telephonyManager.voiceNetworkType
            val is5GByNetworkType = (dataNetworkType == TelephonyManager.NETWORK_TYPE_NR || voiceNetworkType == TelephonyManager.NETWORK_TYPE_NR)

            // Combine detection methods
            val combined5G = is5GActive || has5GCells || is5GByNetworkType

            Log.d(TAG, "5G Detection Summary:")
            Log.d(TAG, "  - TelephonyDisplayInfo: $is5GActive")
            Log.d(TAG, "  - CellInfoNr: $has5GCells")
            Log.d(TAG, "  - NetworkType: $is5GByNetworkType (data=$dataNetworkType, voice=$voiceNetworkType)")
            Log.d(TAG, "  - Combined Result: $combined5G")

            // Update 5G status based on combined detection
            if (combined5G != is5GActive) {
                is5GActive = combined5G
                runOnUiThread { updateNetworkIcons() }
            }

            // Fallback signal reading if no valid cell info
            if (bestSignalStrength4G == -999) {
                try {
                    val signalStrength = telephonyManager.signalStrength
                    signalStrength?.let { ss ->
                        if (ss.isGsm) {
                            val gsmSignal = ss.gsmSignalStrength
                            if (gsmSignal != 99) {
                                bestSignalStrength4G = -113 + 2 * gsmSignal
                                Log.d(TAG, "Fallback GSM signal: ${bestSignalStrength4G}dBm")
                            }
                        }
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Error reading fallback signal: ${e.message}")
                }
            }

            currentCarrier = telephonyManager.networkOperatorName ?: "Unknown"

            // Network type determination
            currentNetworkType = when {
                is5GActive -> "5G NSA"
                has5GCells -> "5G NR"
                dataNetworkType == TelephonyManager.NETWORK_TYPE_LTE -> "LTE"
                else -> "Unknown"
            }

            // FIXED: Use the BEST signal strength available
            currentSignalStrength = when {
                is5GActive && bestSignalStrength5G != -999 -> bestSignalStrength5G
                bestSignalStrength4G != -999 -> bestSignalStrength4G
                else -> -999
            }

            Log.d(TAG, "Final Results: Network=$currentNetworkType, Signal=${currentSignalStrength}dBm, Carrier=$currentCarrier")

            runOnUiThread {
                // Dynamic signal label based on 5G status
                val signalLabel = if (is5GActive) "4G Anchor Signal" else "4G Signal"
                signal4gText.text = "$signalLabel: ${if (bestSignalStrength4G != -999) "${bestSignalStrength4G}dBm" else "No Signal"}"

                signal5gText.text = when {
                    is5GActive && bestSignalStrength5G != -999 -> "5G Signal: ${bestSignalStrength5G}dBm"
                    is5GActive -> "5G Signal: Active"
                    has5GCells -> "5G Signal: Detected (CellInfoNr)"
                    else -> "5G Signal: Not detected"
                }

                generalSignalText.text = "Network: $currentNetworkType\nCarrier: $currentCarrier\nSignal: ${if (currentSignalStrength != -999) "${currentSignalStrength}dBm" else "No Signal"}"
            }

            Log.d(TAG, "=== SIGNAL UPDATE COMPLETE ===")

        } catch (e: Exception) {
            Log.e(TAG, "Error updating signal info: ${e.message}")
            runOnUiThread {
                signal4gText.text = "4G Signal: Error"
                signal5gText.text = "5G Signal: Error"
                generalSignalText.text = "Error reading signal data"
            }
        }
    }

    private fun checkPermissions() {
        val permissions = arrayOf(
            Manifest.permission.ACCESS_FINE_LOCATION,
            Manifest.permission.ACCESS_COARSE_LOCATION,
            Manifest.permission.READ_PHONE_STATE
        )

        val missingPermissions = permissions.filter {
            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED
        }

        if (missingPermissions.isNotEmpty()) {
            ActivityCompat.requestPermissions(this, missingPermissions.toTypedArray(), PERMISSION_REQUEST_CODE)
        } else {
            initializeLocation()
            updateSignalInfo()
            setupTelephonyListener()
        }
    }

    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)

        if (requestCode == PERMISSION_REQUEST_CODE) {
            val allGranted = grantResults.all { it == PackageManager.PERMISSION_GRANTED }
            if (allGranted) {
                initializeLocation()
                updateSignalInfo()
                setupTelephonyListener()
            } else {
                showErrorDialog("Permissions Required", "This app requires location and phone permissions to function properly.")
            }
        }
    }

    @SuppressLint("MissingPermission")
    private fun initializeLocation() {
        try {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                Log.w(TAG, "Location permission not granted")
                return
            }

            if (locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {
                locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 5000, 10f, this)
                lastLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER)
                updateLocationDisplay()
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error initializing location: ${e.message}")
        }
    }

    private fun updateLocationDisplay() {
        runOnUiThread {
            lastLocation?.let { location ->
                gpsInfoText.text = "Lat: ${String.format("%.6f", location.latitude)}\n" +
                        "Lng: ${String.format("%.6f", location.longitude)}\n" +
                        "Accuracy: ${String.format("%.1f", location.accuracy)}m"
            } ?: run {
                gpsInfoText.text = "GPS: Searching for location..."
            }
        }
    }

    private fun startMonitoring() {
        if (isMonitoring) return

        thread {
            discoverServer()

            runOnUiThread {
                if (isServerAvailable) {
                    isMonitoring = true
                    startButton.isEnabled = false
                    stopButton.isEnabled = true
                    statusText.text = "ðŸ“¡ Monitoring active via $connectionType..."

                    startPeriodicUpdates()
                } else {
                    showErrorDialog("Server Error", "Cannot connect to monitoring server. Please check your internet connection or ensure the local server is running.")
                }
            }
        }
    }

    private fun stopMonitoring() {
        isMonitoring = false
        startButton.isEnabled = true
        stopButton.isEnabled = false
        statusText.text = "Monitoring stopped"

        monitoringHandler?.removeCallbacks(monitoringRunnable!!)
        monitoringHandler = null
        monitoringRunnable = null
    }

    private fun startPeriodicUpdates() {
        monitoringHandler = Handler(Looper.getMainLooper())
        monitoringRunnable = object : Runnable {
            override fun run() {
                if (isMonitoring) {
                    updateSignalInfo()
                    sendDataToServer()

                    // Phase 2: Check for queued speed tests (with protection)
                    if (canRunSpeedTest()) {
                        checkForQueuedSpeedTests()
                    }

                    monitoringHandler?.postDelayed(this, 5000)
                }
            }
        }
        monitoringHandler?.post(monitoringRunnable!!)
    }

    /**
     * Enhanced server discovery with HTTPS internet + HTTP local approach
     * Priority: Internet HTTPS > Local HTTP (preserves existing USB/ADB functionality)
     */
    private fun discoverServer() {
        Log.d(TAG, "=== SERVER DISCOVERY START ===")

        val serverUrls = listOf(
            "https://assurance.signal-monitor.com", // Internet HTTPS (priority )

            "http://localhost:5000",     // Local HTTP (existing functionality)
            "http://127.0.0.1:5000"      // Alternative local HTTP
        )

        for (url in serverUrls) {
            Log.d(TAG, "Testing connection to: $url")

            if (testServerConnection(url)) {
                serverBaseUrl = url
                isServerAvailable = true
                connectionType = when {
                    url.startsWith("https://") -> "Internet HTTPS"
                    url.contains("localhost") || url.contains("127.0.0.1") -> "Local HTTP"
                    else -> "Unknown"
                }

                Log.d(TAG, "âœ… SUCCESS: Connected via $connectionType")
                Log.d(TAG, "Server URL: $serverBaseUrl")
                return
            }
        }

        // No connection available
        isServerAvailable = false
        serverBaseUrl = ""
        connectionType = "None"
        Log.e(TAG, "âŒ FAILED: No server connection available")

        Log.d(TAG, "=== SERVER DISCOVERY COMPLETE ===")
    }

    /**
     * Test connection to a specific server URL
     * Handles both HTTPS and HTTP connections appropriately
     */
    private fun testServerConnection(url: String): Boolean {
        return try {
            val connection = if (url.startsWith("https://")) {
                URL("$url/api/health").openConnection() as HttpsURLConnection
            } else {
                URL("$url/api/health").openConnection() as HttpURLConnection
            }

            connection.apply {
                requestMethod = "GET"
                connectTimeout = 5000  // 5 seconds
                readTimeout = 5000     // 5 seconds
                setRequestProperty("User-Agent", "SignalTestEnhanced/1.0")
            }

            val responseCode = connection.responseCode
            val success = responseCode == 200

            Log.d(TAG, "Connection test result: $responseCode (${if (success) "SUCCESS" else "FAILED"})")

            connection.disconnect()
            success

        } catch (e: Exception) {
            Log.e(TAG, "Connection test failed for $url: ${e.message}")
            false
        }
    }

    private fun sendDataToServer() {
        if (!isServerAvailable || lastLocation == null) {
            Log.w(TAG, "Cannot send data: server=${isServerAvailable}, location=${lastLocation != null}")
            return
        }

        thread {
            try {
                val data = JSONObject().apply {
                    put("device_id", deviceId)
                    put("latitude", lastLocation!!.latitude)
                    put("longitude", lastLocation!!.longitude)
                    put("accuracy", lastLocation!!.accuracy)
                    put("signal_strength", currentSignalStrength)
                    put("network_type", if (is5GActive) "NR" else currentNetworkType)
                    put("carrier", currentCarrier)
                    put("timestamp", System.currentTimeMillis())
                    put("is_5g_active", is5GActive)
                    put("connection_type", connectionType)  // Track how we're connected
                }

                // Use appropriate connection type based on server URL
                val connection = if (serverBaseUrl.startsWith("https://")) {
                    URL("$serverBaseUrl/api/signal").openConnection() as HttpsURLConnection
                } else {
                    URL("$serverBaseUrl/api/signal").openConnection() as HttpURLConnection
                }

                connection.apply {
                    requestMethod = "POST"
                    setRequestProperty("Content-Type", "application/json")
                    setRequestProperty("User-Agent", "SignalTestEnhanced/1.0")
                    connectTimeout = 10000  // 10 seconds for data upload
                    readTimeout = 10000
                    doOutput = true
                }

                OutputStreamWriter(connection.outputStream).use { writer ->
                    writer.write(data.toString())
                }

                val responseCode = connection.responseCode
                Log.d(TAG, "Data sent via $connectionType, response: $responseCode")

                runOnUiThread {
                    statusText.text = "ðŸ“¡ Data sent via $connectionType (${responseCode})"
                }

                connection.disconnect()

            } catch (e: Exception) {
                Log.e(TAG, "Error sending data to server: ${e.message}")
                runOnUiThread {
                    statusText.text = "âŒ Server communication error"
                }
            }
        }
    }

    private fun showErrorDialog(title: String, message: String) {
        AlertDialog.Builder(this)
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
            .show()
    }

    override fun onLocationChanged(location: Location) {
        lastLocation = location
        updateLocationDisplay()
    }

    override fun onDestroy() {
        super.onDestroy()

        try {
            if (phoneStateListener != null) {
                telephonyManager.listen(phoneStateListener, PhoneStateListener.LISTEN_NONE)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error unregistering telephony listener: ${e.message}")
        }

        // Speed Test Cleanup (Phase 1 - Dormant)
        isSpeedTestRunning = false
        speedTestExecutor.shutdown()

        stopMonitoring()
    }

    // Speed Test Data Classes (Phase 1 - Dormant)
    private data class SpeedTestResult(
        val downloadSpeed: Double? = null,  // Mbps
        val uploadSpeed: Double? = null,    // Mbps
        val ping: Double? = null,           // ms
        val testDuration: Double? = null,   // seconds
        val timestamp: Long = System.currentTimeMillis(),
        val testServer: String = "",
        val errorMessage: String? = null
    )

    private data class QueueResponse(
        val hasQueuedTest: Boolean,
        val testId: String? = null,
        val testType: String? = null,
        val priority: Int = 0
    )

    // Speed Test Functions (Phase 2 - Active Implementation)
    private fun canRunSpeedTest(): Boolean {
        return !isSpeedTestRunning &&
                !is5GDetectionActive() &&
                isServerAvailable &&
                isMonitoring &&
                !isLowBattery() &&
                canRunSpeedTestNow()
    }

    private fun checkForQueuedSpeedTests() {
        if (!canRunSpeedTest()) return

        speedTestExecutor.execute {
            try {
                val queueResponse = checkSpeedTestQueue()
                if (queueResponse.hasQueuedTest) {
                    executeQueuedSpeedTest(queueResponse.testId!!, queueResponse.testType!!)
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error checking speed test queue: ${e.message}")
            }
        }
    }

    private fun is5GDetectionActive(): Boolean {
        return is5GActive
    }

    private fun isLowBattery(): Boolean {
        // Don't run speed tests if battery < 20%
        return false // Simplified for now
    }

    private var lastSpeedTestTime = 0L
    private val MIN_SPEED_TEST_INTERVAL = 60_000L  // 1 minute minimum

    private fun canRunSpeedTestNow(): Boolean {
        val currentTime = System.currentTimeMillis()
        return (currentTime - lastSpeedTestTime) >= MIN_SPEED_TEST_INTERVAL
    }

    private fun checkSpeedTestQueue(): QueueResponse {
        try {
            val url = URL("$serverBaseUrl/api/devices/$deviceId/speedtest/queue")
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "GET"
            connection.connectTimeout = 5000
            connection.readTimeout = 5000

            if (connection.responseCode == 200) {
                val response = connection.inputStream.bufferedReader().readText()
                val json = JSONObject(response)

                return QueueResponse(
                    hasQueuedTest = json.optBoolean("hasQueuedTest", false),
                    testId = json.optString("testId", null),
                    testType = json.optString("testType", null),
                    priority = json.optInt("priority", 0)
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error checking speed test queue: ${e.message}")
        }

        return QueueResponse(false)
    }

    private fun executeQueuedSpeedTest(testId: String, testType: String) {
        try {
            isSpeedTestRunning = true
            speedTestQueueId = testId
            lastSpeedTestTime = System.currentTimeMillis()

            runOnUiThread {
                updateSpeedTestStatus("Running $testType test...")
            }

            val result = when (testType) {
                "download" -> performDownloadTest(10_000_000) // 10MB
                "upload" -> performUploadTest(5_000_000)      // 5MB
                "ping" -> SpeedTestResult(ping = performPingTest())
                "full" -> performFullSpeedTest()
                else -> throw IllegalArgumentException("Unknown test type: $testType")
            }

            // Report results to server
            reportSpeedTestResults(testId, result)

            runOnUiThread {
                displaySpeedTestResults(result)
            }

        } catch (e: Exception) {
            Log.e(TAG, "Speed test failed: ${e.message}")
            runOnUiThread {
                updateSpeedTestStatus("Speed test failed: ${e.message}")
            }
        } finally {
            isSpeedTestRunning = false
            speedTestQueueId = null
        }
    }

    private fun performDownloadTest(testSizeBytes: Long): SpeedTestResult {
        try {
            val url = URL("$serverBaseUrl/api/speedtest/down?bytes=$testSizeBytes")
            val connection = url.openConnection() as HttpURLConnection
            connection.connectTimeout = 10000
            connection.readTimeout = 30000

            val startTime = System.currentTimeMillis()
            var bytesDownloaded = 0L

            connection.inputStream.use { inputStream ->
                val buffer = ByteArray(8192)
                var bytesRead: Int

                while (inputStream.read(buffer).also { bytesRead = it } != -1 && isSpeedTestRunning) {
                    bytesDownloaded += bytesRead

                    runOnUiThread {
                        updateDownloadProgress(bytesDownloaded, testSizeBytes)
                    }
                }
            }

            val endTime = System.currentTimeMillis()
            val durationSeconds = (endTime - startTime) / 1000.0
            val speedMbps = (bytesDownloaded * 8.0) / (durationSeconds * 1_000_000)

            return SpeedTestResult(
                downloadSpeed = speedMbps,
                testDuration = durationSeconds,
                testServer = serverBaseUrl
            )

        } catch (e: Exception) {
            throw e
        }
    }

    private fun performUploadTest(testSizeBytes: Long): SpeedTestResult {
        try {
            val url = URL("$serverBaseUrl/api/speedtest/up")
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "POST"
            connection.connectTimeout = 10000
            connection.readTimeout = 30000
            connection.setRequestProperty("Content-Type", "application/octet-stream")
            connection.doOutput = true

            val startTime = System.currentTimeMillis()

            connection.outputStream.use { outputStream ->
                val buffer = ByteArray(8192)
                var bytesUploaded = 0L

                while (bytesUploaded < testSizeBytes && isSpeedTestRunning) {
                    val bytesToWrite = minOf(buffer.size.toLong(), testSizeBytes - bytesUploaded).toInt()
                    outputStream.write(buffer, 0, bytesToWrite)
                    bytesUploaded += bytesToWrite

                    runOnUiThread {
                        updateUploadProgress(bytesUploaded, testSizeBytes)
                    }
                }
            }

            val responseCode = connection.responseCode
            val endTime = System.currentTimeMillis()

            if (responseCode == 200) {
                val durationSeconds = (endTime - startTime) / 1000.0
                val speedMbps = (testSizeBytes * 8.0) / (durationSeconds * 1_000_000)

                return SpeedTestResult(
                    uploadSpeed = speedMbps,
                    testDuration = durationSeconds,
                    testServer = serverBaseUrl
                )
            } else {
                throw Exception("Upload test failed with response code: $responseCode")
            }

        } catch (e: Exception) {
            throw e
        }
    }

    private fun performPingTest(): Double {
        try {
            val url = URL("$serverBaseUrl/api/health")
            val connection = url.openConnection() as HttpURLConnection
            connection.connectTimeout = 5000
            connection.readTimeout = 5000

            val startTime = System.nanoTime()
            val responseCode = connection.responseCode
            val endTime = System.nanoTime()

            if (responseCode == 200) {
                return (endTime - startTime) / 1_000_000.0  // Convert to milliseconds
            } else {
                throw Exception("Ping test failed with response code: $responseCode")
            }

        } catch (e: Exception) {
            throw e
        }
    }

    private fun performFullSpeedTest(): SpeedTestResult {
        val ping = performPingTest()
        val downloadResult = performDownloadTest(10_000_000)
        val uploadResult = performUploadTest(5_000_000)

        return SpeedTestResult(
            downloadSpeed = downloadResult.downloadSpeed,
            uploadSpeed = uploadResult.uploadSpeed,
            ping = ping,
            testDuration = (downloadResult.testDuration ?: 0.0) + (uploadResult.testDuration ?: 0.0),
            testServer = serverBaseUrl
        )
    }

    private fun reportSpeedTestResults(testId: String, result: SpeedTestResult) {
        try {
            val url = URL("$serverBaseUrl/api/devices/$deviceId/speedtest")
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "POST"
            connection.setRequestProperty("Content-Type", "application/json")
            connection.doOutput = true

            val jsonData = JSONObject().apply {
                put("testId", testId)
                put("downloadSpeed", result.downloadSpeed)
                put("uploadSpeed", result.uploadSpeed)
                put("ping", result.ping)
                put("testDuration", result.testDuration)
                put("testServer", result.testServer)
                put("timestamp", result.timestamp)
            }

            OutputStreamWriter(connection.outputStream).use { writer ->
                writer.write(jsonData.toString())
            }

            val responseCode = connection.responseCode
            Log.d(TAG, "Speed test results reported: $responseCode")

        } catch (e: Exception) {
            Log.e(TAG, "Error reporting speed test results: ${e.message}")
        }
    }

    private fun updateSpeedTestStatus(status: String) {
        Log.d(TAG, "Speed Test Status: $status")
        // Could update UI here if needed
    }

    private fun updateDownloadProgress(downloaded: Long, total: Long) {
        val progress = (downloaded * 100 / total).toInt()
        val speed = calculateCurrentSpeed(downloaded)
        Log.d(TAG, "Download Progress: $progress% - ${String.format("%.2f", speed)} Mbps")
    }

    private fun updateUploadProgress(uploaded: Long, total: Long) {
        val progress = (uploaded * 100 / total).toInt()
        val speed = calculateCurrentSpeed(uploaded)
        Log.d(TAG, "Upload Progress: $progress% - ${String.format("%.2f", speed)} Mbps")
    }

    private fun calculateCurrentSpeed(bytes: Long): Double {
        val currentTime = System.currentTimeMillis()
        val elapsedSeconds = (currentTime - lastSpeedTestTime) / 1000.0
        return if (elapsedSeconds > 0) (bytes * 8.0) / (elapsedSeconds * 1_000_000) else 0.0
    }

    private fun displaySpeedTestResults(result: SpeedTestResult) {
        val resultsText = buildString {
            result.downloadSpeed?.let { append("Download: ${String.format("%.2f", it)} Mbps\n") }
            result.uploadSpeed?.let { append("Upload: ${String.format("%.2f", it)} Mbps\n") }
            result.ping?.let { append("Ping: ${String.format("%.1f", it)} ms\n") }
        }

        Log.d(TAG, "Speed Test Results:\n$resultsText")
        updateSpeedTestStatus("Test completed: $resultsText")
    }
}